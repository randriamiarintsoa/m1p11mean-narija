import { Component, DestroyRef, EventEmitter, HostBinding, inject, Inject, Input, Output } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { fromEvent } from 'rxjs';
import { filter, finalize, withLatestFrom, zipWith } from 'rxjs/operators';
import { ListenersService } from '../../services';
import { CarouselState } from '../carousel-state';
import { CarouselService } from '../carousel.service';
import { CarouselConfig } from '../carousel.config';
import * as i0 from "@angular/core";
import * as i1 from "../carousel.service";
import * as i2 from "../carousel-state";
import * as i3 from "../../services";
import * as i4 from "../carousel.config";
export class CarouselComponent {
    get hostClasses() {
        return {
            carousel: true,
            slide: true,
            'carousel-dark': !!this.dark,
            'carousel-fade': this.transition === 'crossfade'
        };
    }
    #destroyRef;
    constructor(config, hostElement, carouselService, carouselState, intersectionService, listenersService) {
        this.config = config;
        this.hostElement = hostElement;
        this.carouselService = carouselService;
        this.carouselState = carouselState;
        this.intersectionService = intersectionService;
        this.listenersService = listenersService;
        /**
         * Index of the active item.
         * @type number
         */
        this.activeIndex = 0;
        /**
         * Carousel automatically starts cycle items.
         * @type boolean
         */
        this.animate = true;
        /**
         * Carousel direction. [docs]
         * @type {'next' | 'prev'}
         */
        this.direction = 'next';
        /**
         * The amount of time to delay between automatically cycling an item. If false, carousel will not automatically cycle.
         * @type number
         * @default 0
         */
        this.interval = 0;
        /**
         * Sets which event handlers you’d like provided to your pause prop. You can specify one trigger or an array of them.
         * @type {'hover' | 'focus' | 'click'}
         */
        this.pause = 'hover';
        /**
         * Support left/right swipe interactions on touchscreen devices.
         * @type boolean
         * @default true
         */
        this.touch = true;
        /**
         * Set type of the transition.
         * @type {'slide' | 'crossfade'}
         * @default 'slide'
         */
        this.transition = 'slide';
        /**
         * Set whether the carousel should cycle continuously or have hard stops.
         * @type boolean
         * @default true
         */
        this.wrap = true;
        /**
         * Event emitted on carousel item change. [docs]
         * @type number
         */
        this.itemChange = new EventEmitter();
        this.activeItemInterval = 0;
        this.#destroyRef = inject(DestroyRef);
        this._visible = true;
        Object.assign(this, config);
    }
    ngOnInit() {
        this.carouselStateSubscribe();
    }
    ngOnDestroy() {
        this.resetTimer();
        this.clearListeners();
        this.swipeSubscribe(false);
    }
    ngAfterContentInit() {
        this.intersectionServiceSubscribe();
        this.carouselState.state = { activeItemIndex: this.activeIndex, animate: this.animate };
        this.setListeners();
        this.swipeSubscribe();
    }
    setListeners() {
        const config = {
            hostElement: this.hostElement,
            trigger: this.pause || [],
            callbackOff: () => {
                this.setTimer();
            },
            callbackOn: () => {
                this.resetTimer();
            }
        };
        this.listenersService.setListeners(config);
    }
    clearListeners() {
        this.listenersService.clearListeners();
    }
    set visible(value) {
        this._visible = value;
    }
    get visible() {
        return this._visible;
    }
    setTimer() {
        const interval = this.activeItemInterval || 0;
        this.resetTimer();
        if (interval > 0) {
            this.timerId = setTimeout(() => {
                const nextIndex = this.carouselState.direction(this.direction);
                this.carouselState.state = { activeItemIndex: nextIndex };
            }, interval);
        }
    }
    resetTimer() {
        clearTimeout(this.timerId);
        this.timerId = undefined;
    }
    carouselStateSubscribe() {
        this.carouselService.carouselIndex$
            .pipe(takeUntilDestroyed(this.#destroyRef))
            .subscribe((nextItem) => {
            if ('active' in nextItem) {
                this.itemChange.emit(nextItem.active);
            }
            this.activeItemInterval = typeof nextItem.interval === 'number' && nextItem.interval > -1 ? nextItem.interval : this.interval;
            const isLastItem = ((nextItem.active === nextItem.lastItemIndex) && this.direction === 'next') || ((nextItem.active === 0) && this.direction === 'prev');
            !this.wrap && isLastItem ? this.resetTimer() : this.setTimer();
        });
    }
    intersectionServiceSubscribe() {
        this.intersectionService.intersecting$
            .pipe(filter(next => next.hostElement === this.hostElement), finalize(() => {
            this.intersectionService.unobserve(this.hostElement);
        }), takeUntilDestroyed(this.#destroyRef))
            .subscribe(next => {
            this.visible = next.isIntersecting;
            next.isIntersecting ? this.setTimer() : this.resetTimer();
        });
        this.intersectionService.createIntersectionObserver(this.hostElement);
    }
    swipeSubscribe(subscribe = true) {
        if (this.touch && subscribe) {
            const carouselElement = this.hostElement.nativeElement;
            const touchStart$ = fromEvent(carouselElement, 'touchstart');
            const touchEnd$ = fromEvent(carouselElement, 'touchend');
            const touchMove$ = fromEvent(carouselElement, 'touchmove');
            this.swipeSubscription = touchStart$.pipe(zipWith(touchEnd$.pipe(withLatestFrom(touchMove$))), takeUntilDestroyed(this.#destroyRef))
                .subscribe(([touchstart, [touchend, touchmove]]) => {
                touchstart.stopPropagation();
                touchmove.stopPropagation();
                const distanceX = touchstart.touches[0].clientX - touchmove.touches[0].clientX;
                if (Math.abs(distanceX) > 0.3 * carouselElement.clientWidth && touchstart.timeStamp <= touchmove.timeStamp) {
                    const nextIndex = this.carouselState.direction(distanceX > 0 ? 'next' : 'prev');
                    this.carouselState.state = { activeItemIndex: nextIndex };
                }
            });
        }
        else {
            this.swipeSubscription?.unsubscribe();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.1.2", ngImport: i0, type: CarouselComponent, deps: [{ token: CarouselConfig }, { token: i0.ElementRef }, { token: i1.CarouselService }, { token: i2.CarouselState }, { token: i3.IntersectionService }, { token: i3.ListenersService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.1.2", type: CarouselComponent, isStandalone: true, selector: "c-carousel", inputs: { activeIndex: "activeIndex", animate: "animate", dark: "dark", direction: "direction", interval: "interval", pause: "pause", touch: "touch", transition: "transition", wrap: "wrap" }, outputs: { itemChange: "itemChange" }, host: { properties: { "class": "this.hostClasses" } }, providers: [CarouselService, CarouselState, CarouselConfig, ListenersService], ngImport: i0, template: '<ng-content></ng-content>', isInline: true, styles: [":host{display:block}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.1.2", ngImport: i0, type: CarouselComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-carousel', template: '<ng-content></ng-content>', providers: [CarouselService, CarouselState, CarouselConfig, ListenersService], standalone: true, styles: [":host{display:block}\n"] }]
        }], ctorParameters: () => [{ type: i4.CarouselConfig, decorators: [{
                    type: Inject,
                    args: [CarouselConfig]
                }] }, { type: i0.ElementRef }, { type: i1.CarouselService }, { type: i2.CarouselState }, { type: i3.IntersectionService }, { type: i3.ListenersService }], propDecorators: { activeIndex: [{
                type: Input
            }], animate: [{
                type: Input
            }], dark: [{
                type: Input
            }], direction: [{
                type: Input
            }], interval: [{
                type: Input
            }], pause: [{
                type: Input
            }], touch: [{
                type: Input
            }], transition: [{
                type: Input
            }], wrap: [{
                type: Input
            }], itemChange: [{
                type: Output
            }], hostClasses: [{
                type: HostBinding,
                args: ['class']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2Fyb3VzZWwuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY29yZXVpLWFuZ3VsYXIvc3JjL2xpYi9jYXJvdXNlbC9jYXJvdXNlbC9jYXJvdXNlbC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVMLFNBQVMsRUFDVCxVQUFVLEVBRVYsWUFBWSxFQUNaLFdBQVcsRUFDWCxNQUFNLEVBQ04sTUFBTSxFQUNOLEtBQUssRUFHTCxNQUFNLEVBQ1AsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDaEUsT0FBTyxFQUFFLFNBQVMsRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDL0MsT0FBTyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFLE9BQU8sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRzNFLE9BQU8sRUFBb0IsZ0JBQWdCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVwRSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDbEQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3RELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQzs7Ozs7O0FBVXBELE1BQU0sT0FBTyxpQkFBaUI7SUF3RDVCLElBQ0ksV0FBVztRQUNiLE9BQU87WUFDTCxRQUFRLEVBQUUsSUFBSTtZQUNkLEtBQUssRUFBRSxJQUFJO1lBQ1gsZUFBZSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSTtZQUM1QixlQUFlLEVBQUUsSUFBSSxDQUFDLFVBQVUsS0FBSyxXQUFXO1NBQ2pELENBQUM7SUFDSixDQUFDO0lBS1EsV0FBVyxDQUFzQjtJQUUxQyxZQUNrQyxNQUFzQixFQUM5QyxXQUF1QixFQUN2QixlQUFnQyxFQUNoQyxhQUE0QixFQUM1QixtQkFBd0MsRUFDeEMsZ0JBQWtDO1FBTFYsV0FBTSxHQUFOLE1BQU0sQ0FBZ0I7UUFDOUMsZ0JBQVcsR0FBWCxXQUFXLENBQVk7UUFDdkIsb0JBQWUsR0FBZixlQUFlLENBQWlCO1FBQ2hDLGtCQUFhLEdBQWIsYUFBYSxDQUFlO1FBQzVCLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBcUI7UUFDeEMscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQjtRQTVFNUM7OztXQUdHO1FBQ00sZ0JBQVcsR0FBVyxDQUFDLENBQUM7UUFDakM7OztXQUdHO1FBQ00sWUFBTyxHQUFZLElBQUksQ0FBQztRQU1qQzs7O1dBR0c7UUFDTSxjQUFTLEdBQW9CLE1BQU0sQ0FBQztRQUM3Qzs7OztXQUlHO1FBQ00sYUFBUSxHQUFXLENBQUMsQ0FBQztRQUM5Qjs7O1dBR0c7UUFDTSxVQUFLLEdBQWtDLE9BQU8sQ0FBQztRQUN4RDs7OztXQUlHO1FBQ00sVUFBSyxHQUFZLElBQUksQ0FBQztRQUMvQjs7OztXQUlHO1FBQ00sZUFBVSxHQUEwQixPQUFPLENBQUM7UUFDckQ7Ozs7V0FJRztRQUNNLFNBQUksR0FBWSxJQUFJLENBQUM7UUFDOUI7OztXQUdHO1FBQ08sZUFBVSxHQUF5QixJQUFJLFlBQVksRUFBVSxDQUFDO1FBYWhFLHVCQUFrQixHQUFHLENBQUMsQ0FBQztRQUV0QixnQkFBVyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztRQXdEbEMsYUFBUSxHQUFZLElBQUksQ0FBQztRQTlDL0IsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVELFFBQVE7UUFDTixJQUFJLENBQUMsc0JBQXNCLEVBQUUsQ0FBQztJQUNoQyxDQUFDO0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUNsQixJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDdEIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQsa0JBQWtCO1FBQ2hCLElBQUksQ0FBQyw0QkFBNEIsRUFBRSxDQUFDO1FBQ3BDLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxHQUFHLEVBQUUsZUFBZSxFQUFFLElBQUksQ0FBQyxXQUFXLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUN4RixJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDcEIsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO0lBQ3hCLENBQUM7SUFFTyxZQUFZO1FBQ2xCLE1BQU0sTUFBTSxHQUFxQjtZQUMvQixXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVc7WUFDN0IsT0FBTyxFQUFFLElBQUksQ0FBQyxLQUFLLElBQUksRUFBRTtZQUN6QixXQUFXLEVBQUUsR0FBRyxFQUFFO2dCQUNoQixJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDbEIsQ0FBQztZQUNELFVBQVUsRUFBRSxHQUFHLEVBQUU7Z0JBQ2YsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBQ3BCLENBQUM7U0FDRixDQUFDO1FBQ0YsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRU8sY0FBYztRQUNwQixJQUFJLENBQUMsZ0JBQWdCLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDekMsQ0FBQztJQUVELElBQUksT0FBTyxDQUFDLEtBQUs7UUFDZixJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztJQUN4QixDQUFDO0lBRUQsSUFBSSxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3ZCLENBQUM7SUFJRCxRQUFRO1FBQ04sTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixJQUFJLENBQUMsQ0FBQztRQUM5QyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDbEIsSUFBSSxRQUFRLEdBQUcsQ0FBQyxFQUFFO1lBQ2hCLElBQUksQ0FBQyxPQUFPLEdBQUcsVUFBVSxDQUFDLEdBQUcsRUFBRTtnQkFDN0IsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUMvRCxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssR0FBRyxFQUFFLGVBQWUsRUFBRSxTQUFTLEVBQUUsQ0FBQztZQUM1RCxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUM7U0FDZDtJQUNILENBQUM7SUFFRCxVQUFVO1FBQ1IsWUFBWSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMzQixJQUFJLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQztJQUMzQixDQUFDO0lBRU8sc0JBQXNCO1FBQzVCLElBQUksQ0FBQyxlQUFlLENBQUMsY0FBYzthQUNoQyxJQUFJLENBQ0gsa0JBQWtCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUNyQzthQUNBLFNBQVMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQ3RCLElBQUksUUFBUSxJQUFJLFFBQVEsRUFBRTtnQkFDeEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ3ZDO1lBQ0QsSUFBSSxDQUFDLGtCQUFrQixHQUFHLE9BQU8sUUFBUSxDQUFDLFFBQVEsS0FBSyxRQUFRLElBQUksUUFBUSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztZQUM5SCxNQUFNLFVBQVUsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUMsYUFBYSxDQUFDLElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLE1BQU0sQ0FBQyxDQUFDO1lBQ3pKLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2pFLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVPLDRCQUE0QjtRQUNsQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsYUFBYTthQUNuQyxJQUFJLENBQ0gsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsS0FBSyxJQUFJLENBQUMsV0FBVyxDQUFDLEVBQ3JELFFBQVEsQ0FBQyxHQUFHLEVBQUU7WUFDWixJQUFJLENBQUMsbUJBQW1CLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUN2RCxDQUFDLENBQUMsRUFDRixrQkFBa0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQ3JDO2FBQ0EsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2hCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQztZQUNuQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUM1RCxDQUFDLENBQUMsQ0FBQztRQUNMLElBQUksQ0FBQyxtQkFBbUIsQ0FBQywwQkFBMEIsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDeEUsQ0FBQztJQUVPLGNBQWMsQ0FBQyxZQUFxQixJQUFJO1FBQzlDLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxTQUFTLEVBQUU7WUFDM0IsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUM7WUFDdkQsTUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFhLGVBQWUsRUFBRSxZQUFZLENBQUMsQ0FBQztZQUN6RSxNQUFNLFNBQVMsR0FBRyxTQUFTLENBQWEsZUFBZSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1lBQ3JFLE1BQU0sVUFBVSxHQUFHLFNBQVMsQ0FBYSxlQUFlLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFDdkUsSUFBSSxDQUFDLGlCQUFpQixHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQ3ZDLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQ25ELGtCQUFrQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FDckM7aUJBQ0UsU0FBUyxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFO2dCQUNqRCxVQUFVLENBQUMsZUFBZSxFQUFFLENBQUM7Z0JBQzdCLFNBQVMsQ0FBQyxlQUFlLEVBQUUsQ0FBQztnQkFDNUIsTUFBTSxTQUFTLEdBQUcsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUM7Z0JBQy9FLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLEdBQUcsZUFBZSxDQUFDLFdBQVcsSUFBSSxVQUFVLENBQUMsU0FBUyxJQUFJLFNBQVMsQ0FBQyxTQUFTLEVBQUU7b0JBQzFHLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7b0JBQ2hGLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxHQUFHLEVBQUUsZUFBZSxFQUFFLFNBQVMsRUFBRSxDQUFDO2lCQUMzRDtZQUNILENBQUMsQ0FBQyxDQUFDO1NBQ047YUFBTTtZQUNMLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxXQUFXLEVBQUUsQ0FBQztTQUN2QztJQUNILENBQUM7OEdBcE1VLGlCQUFpQixrQkF3RWxCLGNBQWM7a0dBeEViLGlCQUFpQix1VkFIakIsQ0FBQyxlQUFlLEVBQUUsYUFBYSxFQUFFLGNBQWMsRUFBRSxnQkFBZ0IsQ0FBQywwQkFGbkUsMkJBQTJCOzsyRkFLMUIsaUJBQWlCO2tCQVA3QixTQUFTOytCQUNFLFlBQVksWUFDWiwyQkFBMkIsYUFFMUIsQ0FBQyxlQUFlLEVBQUUsYUFBYSxFQUFFLGNBQWMsRUFBRSxnQkFBZ0IsQ0FBQyxjQUNqRSxJQUFJOzswQkEwRWIsTUFBTTsyQkFBQyxjQUFjOzZMQW5FZixXQUFXO3NCQUFuQixLQUFLO2dCQUtHLE9BQU87c0JBQWYsS0FBSztnQkFLRyxJQUFJO3NCQUFaLEtBQUs7Z0JBS0csU0FBUztzQkFBakIsS0FBSztnQkFNRyxRQUFRO3NCQUFoQixLQUFLO2dCQUtHLEtBQUs7c0JBQWIsS0FBSztnQkFNRyxLQUFLO3NCQUFiLEtBQUs7Z0JBTUcsVUFBVTtzQkFBbEIsS0FBSztnQkFNRyxJQUFJO3NCQUFaLEtBQUs7Z0JBS0ksVUFBVTtzQkFBbkIsTUFBTTtnQkFHSCxXQUFXO3NCQURkLFdBQVc7dUJBQUMsT0FBTyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIENvbXBvbmVudCxcbiAgRGVzdHJveVJlZixcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBIb3N0QmluZGluZyxcbiAgaW5qZWN0LFxuICBJbmplY3QsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3V0cHV0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdGFrZVVudGlsRGVzdHJveWVkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZS9yeGpzLWludGVyb3AnO1xuaW1wb3J0IHsgZnJvbUV2ZW50LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgZmluYWxpemUsIHdpdGhMYXRlc3RGcm9tLCB6aXBXaXRoIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBJbnRlcnNlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMnO1xuaW1wb3J0IHsgSUxpc3RlbmVyc0NvbmZpZywgTGlzdGVuZXJzU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzJztcblxuaW1wb3J0IHsgQ2Fyb3VzZWxTdGF0ZSB9IGZyb20gJy4uL2Nhcm91c2VsLXN0YXRlJztcbmltcG9ydCB7IENhcm91c2VsU2VydmljZSB9IGZyb20gJy4uL2Nhcm91c2VsLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2Fyb3VzZWxDb25maWcgfSBmcm9tICcuLi9jYXJvdXNlbC5jb25maWcnO1xuaW1wb3J0IHsgVHJpZ2dlcnMgfSBmcm9tICcuLi8uLi9jb3JldWkudHlwZXMnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjLWNhcm91c2VsJyxcbiAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgc3R5bGVVcmxzOiBbJy4vY2Fyb3VzZWwuY29tcG9uZW50LnNjc3MnXSxcbiAgcHJvdmlkZXJzOiBbQ2Fyb3VzZWxTZXJ2aWNlLCBDYXJvdXNlbFN0YXRlLCBDYXJvdXNlbENvbmZpZywgTGlzdGVuZXJzU2VydmljZV0sXG4gIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgQ2Fyb3VzZWxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSwgQWZ0ZXJDb250ZW50SW5pdCB7XG4gIC8qKlxuICAgKiBJbmRleCBvZiB0aGUgYWN0aXZlIGl0ZW0uXG4gICAqIEB0eXBlIG51bWJlclxuICAgKi9cbiAgQElucHV0KCkgYWN0aXZlSW5kZXg6IG51bWJlciA9IDA7XG4gIC8qKlxuICAgKiBDYXJvdXNlbCBhdXRvbWF0aWNhbGx5IHN0YXJ0cyBjeWNsZSBpdGVtcy5cbiAgICogQHR5cGUgYm9vbGVhblxuICAgKi9cbiAgQElucHV0KCkgYW5pbWF0ZTogYm9vbGVhbiA9IHRydWU7XG4gIC8qKlxuICAgKiBBZGQgZGFya2VyIGNvbnRyb2xzLCBpbmRpY2F0b3JzLCBhbmQgY2FwdGlvbnMuXG4gICAqIEB0eXBlIGJvb2xlYW5cbiAgICovXG4gIEBJbnB1dCgpIGRhcms/OiBib29sZWFuO1xuICAvKipcbiAgICogQ2Fyb3VzZWwgZGlyZWN0aW9uLiBbZG9jc11cbiAgICogQHR5cGUgeyduZXh0JyB8ICdwcmV2J31cbiAgICovXG4gIEBJbnB1dCgpIGRpcmVjdGlvbjogJ25leHQnIHwgJ3ByZXYnID0gJ25leHQnO1xuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IGJldHdlZW4gYXV0b21hdGljYWxseSBjeWNsaW5nIGFuIGl0ZW0uIElmIGZhbHNlLCBjYXJvdXNlbCB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IGN5Y2xlLlxuICAgKiBAdHlwZSBudW1iZXJcbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgQElucHV0KCkgaW50ZXJ2YWw6IG51bWJlciA9IDA7XG4gIC8qKlxuICAgKiBTZXRzIHdoaWNoIGV2ZW50IGhhbmRsZXJzIHlvdeKAmWQgbGlrZSBwcm92aWRlZCB0byB5b3VyIHBhdXNlIHByb3AuIFlvdSBjYW4gc3BlY2lmeSBvbmUgdHJpZ2dlciBvciBhbiBhcnJheSBvZiB0aGVtLlxuICAgKiBAdHlwZSB7J2hvdmVyJyB8ICdmb2N1cycgfCAnY2xpY2snfVxuICAgKi9cbiAgQElucHV0KCkgcGF1c2U6IFRyaWdnZXJzIHwgVHJpZ2dlcnNbXSB8IGZhbHNlID0gJ2hvdmVyJztcbiAgLyoqXG4gICAqIFN1cHBvcnQgbGVmdC9yaWdodCBzd2lwZSBpbnRlcmFjdGlvbnMgb24gdG91Y2hzY3JlZW4gZGV2aWNlcy5cbiAgICogQHR5cGUgYm9vbGVhblxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBASW5wdXQoKSB0b3VjaDogYm9vbGVhbiA9IHRydWU7XG4gIC8qKlxuICAgKiBTZXQgdHlwZSBvZiB0aGUgdHJhbnNpdGlvbi5cbiAgICogQHR5cGUgeydzbGlkZScgfCAnY3Jvc3NmYWRlJ31cbiAgICogQGRlZmF1bHQgJ3NsaWRlJ1xuICAgKi9cbiAgQElucHV0KCkgdHJhbnNpdGlvbjogJ3NsaWRlJyB8ICdjcm9zc2ZhZGUnID0gJ3NsaWRlJztcbiAgLyoqXG4gICAqIFNldCB3aGV0aGVyIHRoZSBjYXJvdXNlbCBzaG91bGQgY3ljbGUgY29udGludW91c2x5IG9yIGhhdmUgaGFyZCBzdG9wcy5cbiAgICogQHR5cGUgYm9vbGVhblxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBASW5wdXQoKSB3cmFwOiBib29sZWFuID0gdHJ1ZTtcbiAgLyoqXG4gICAqIEV2ZW50IGVtaXR0ZWQgb24gY2Fyb3VzZWwgaXRlbSBjaGFuZ2UuIFtkb2NzXVxuICAgKiBAdHlwZSBudW1iZXJcbiAgICovXG4gIEBPdXRwdXQoKSBpdGVtQ2hhbmdlOiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gIEBIb3N0QmluZGluZygnY2xhc3MnKVxuICBnZXQgaG9zdENsYXNzZXMoKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgY2Fyb3VzZWw6IHRydWUsXG4gICAgICBzbGlkZTogdHJ1ZSxcbiAgICAgICdjYXJvdXNlbC1kYXJrJzogISF0aGlzLmRhcmssXG4gICAgICAnY2Fyb3VzZWwtZmFkZSc6IHRoaXMudHJhbnNpdGlvbiA9PT0gJ2Nyb3NzZmFkZSdcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSB0aW1lcklkOiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBhY3RpdmVJdGVtSW50ZXJ2YWwgPSAwO1xuICBwcml2YXRlIHN3aXBlU3Vic2NyaXB0aW9uPzogU3Vic2NyaXB0aW9uO1xuICByZWFkb25seSAjZGVzdHJveVJlZiA9IGluamVjdChEZXN0cm95UmVmKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KENhcm91c2VsQ29uZmlnKSBwcml2YXRlIGNvbmZpZzogQ2Fyb3VzZWxDb25maWcsXG4gICAgcHJpdmF0ZSBob3N0RWxlbWVudDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIGNhcm91c2VsU2VydmljZTogQ2Fyb3VzZWxTZXJ2aWNlLFxuICAgIHByaXZhdGUgY2Fyb3VzZWxTdGF0ZTogQ2Fyb3VzZWxTdGF0ZSxcbiAgICBwcml2YXRlIGludGVyc2VjdGlvblNlcnZpY2U6IEludGVyc2VjdGlvblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBsaXN0ZW5lcnNTZXJ2aWNlOiBMaXN0ZW5lcnNTZXJ2aWNlXG4gICkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgY29uZmlnKTtcbiAgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMuY2Fyb3VzZWxTdGF0ZVN1YnNjcmliZSgpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5yZXNldFRpbWVyKCk7XG4gICAgdGhpcy5jbGVhckxpc3RlbmVycygpO1xuICAgIHRoaXMuc3dpcGVTdWJzY3JpYmUoZmFsc2UpO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuICAgIHRoaXMuaW50ZXJzZWN0aW9uU2VydmljZVN1YnNjcmliZSgpO1xuICAgIHRoaXMuY2Fyb3VzZWxTdGF0ZS5zdGF0ZSA9IHsgYWN0aXZlSXRlbUluZGV4OiB0aGlzLmFjdGl2ZUluZGV4LCBhbmltYXRlOiB0aGlzLmFuaW1hdGUgfTtcbiAgICB0aGlzLnNldExpc3RlbmVycygpO1xuICAgIHRoaXMuc3dpcGVTdWJzY3JpYmUoKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0TGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIGNvbnN0IGNvbmZpZzogSUxpc3RlbmVyc0NvbmZpZyA9IHtcbiAgICAgIGhvc3RFbGVtZW50OiB0aGlzLmhvc3RFbGVtZW50LFxuICAgICAgdHJpZ2dlcjogdGhpcy5wYXVzZSB8fCBbXSxcbiAgICAgIGNhbGxiYWNrT2ZmOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0VGltZXIoKTtcbiAgICAgIH0sXG4gICAgICBjYWxsYmFja09uOiAoKSA9PiB7XG4gICAgICAgIHRoaXMucmVzZXRUaW1lcigpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5saXN0ZW5lcnNTZXJ2aWNlLnNldExpc3RlbmVycyhjb25maWcpO1xuICB9XG5cbiAgcHJpdmF0ZSBjbGVhckxpc3RlbmVycygpOiB2b2lkIHtcbiAgICB0aGlzLmxpc3RlbmVyc1NlcnZpY2UuY2xlYXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHNldCB2aXNpYmxlKHZhbHVlKSB7XG4gICAgdGhpcy5fdmlzaWJsZSA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gIH1cblxuICBwcml2YXRlIF92aXNpYmxlOiBib29sZWFuID0gdHJ1ZTtcblxuICBzZXRUaW1lcigpOiB2b2lkIHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IHRoaXMuYWN0aXZlSXRlbUludGVydmFsIHx8IDA7XG4gICAgdGhpcy5yZXNldFRpbWVyKCk7XG4gICAgaWYgKGludGVydmFsID4gMCkge1xuICAgICAgdGhpcy50aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHRJbmRleCA9IHRoaXMuY2Fyb3VzZWxTdGF0ZS5kaXJlY3Rpb24odGhpcy5kaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLmNhcm91c2VsU3RhdGUuc3RhdGUgPSB7IGFjdGl2ZUl0ZW1JbmRleDogbmV4dEluZGV4IH07XG4gICAgICB9LCBpbnRlcnZhbCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRUaW1lcigpOiB2b2lkIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICB0aGlzLnRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBwcml2YXRlIGNhcm91c2VsU3RhdGVTdWJzY3JpYmUoKTogdm9pZCB7XG4gICAgdGhpcy5jYXJvdXNlbFNlcnZpY2UuY2Fyb3VzZWxJbmRleCRcbiAgICAgIC5waXBlKFxuICAgICAgICB0YWtlVW50aWxEZXN0cm95ZWQodGhpcy4jZGVzdHJveVJlZilcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKG5leHRJdGVtKSA9PiB7XG4gICAgICAgIGlmICgnYWN0aXZlJyBpbiBuZXh0SXRlbSkge1xuICAgICAgICAgIHRoaXMuaXRlbUNoYW5nZS5lbWl0KG5leHRJdGVtLmFjdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVJdGVtSW50ZXJ2YWwgPSB0eXBlb2YgbmV4dEl0ZW0uaW50ZXJ2YWwgPT09ICdudW1iZXInICYmIG5leHRJdGVtLmludGVydmFsID4gLTEgPyBuZXh0SXRlbS5pbnRlcnZhbCA6IHRoaXMuaW50ZXJ2YWw7XG4gICAgICAgIGNvbnN0IGlzTGFzdEl0ZW0gPSAoKG5leHRJdGVtLmFjdGl2ZSA9PT0gbmV4dEl0ZW0ubGFzdEl0ZW1JbmRleCkgJiYgdGhpcy5kaXJlY3Rpb24gPT09ICduZXh0JykgfHwgKChuZXh0SXRlbS5hY3RpdmUgPT09IDApICYmIHRoaXMuZGlyZWN0aW9uID09PSAncHJldicpO1xuICAgICAgICAhdGhpcy53cmFwICYmIGlzTGFzdEl0ZW0gPyB0aGlzLnJlc2V0VGltZXIoKSA6IHRoaXMuc2V0VGltZXIoKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBpbnRlcnNlY3Rpb25TZXJ2aWNlU3Vic2NyaWJlKCk6IHZvaWQge1xuICAgIHRoaXMuaW50ZXJzZWN0aW9uU2VydmljZS5pbnRlcnNlY3RpbmckXG4gICAgICAucGlwZShcbiAgICAgICAgZmlsdGVyKG5leHQgPT4gbmV4dC5ob3N0RWxlbWVudCA9PT0gdGhpcy5ob3N0RWxlbWVudCksXG4gICAgICAgIGZpbmFsaXplKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmludGVyc2VjdGlvblNlcnZpY2UudW5vYnNlcnZlKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgICB9KSxcbiAgICAgICAgdGFrZVVudGlsRGVzdHJveWVkKHRoaXMuI2Rlc3Ryb3lSZWYpXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKG5leHQgPT4ge1xuICAgICAgICB0aGlzLnZpc2libGUgPSBuZXh0LmlzSW50ZXJzZWN0aW5nO1xuICAgICAgICBuZXh0LmlzSW50ZXJzZWN0aW5nID8gdGhpcy5zZXRUaW1lcigpIDogdGhpcy5yZXNldFRpbWVyKCk7XG4gICAgICB9KTtcbiAgICB0aGlzLmludGVyc2VjdGlvblNlcnZpY2UuY3JlYXRlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIodGhpcy5ob3N0RWxlbWVudCk7XG4gIH1cblxuICBwcml2YXRlIHN3aXBlU3Vic2NyaWJlKHN1YnNjcmliZTogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgICBpZiAodGhpcy50b3VjaCAmJiBzdWJzY3JpYmUpIHtcbiAgICAgIGNvbnN0IGNhcm91c2VsRWxlbWVudCA9IHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgIGNvbnN0IHRvdWNoU3RhcnQkID0gZnJvbUV2ZW50PFRvdWNoRXZlbnQ+KGNhcm91c2VsRWxlbWVudCwgJ3RvdWNoc3RhcnQnKTtcbiAgICAgIGNvbnN0IHRvdWNoRW5kJCA9IGZyb21FdmVudDxUb3VjaEV2ZW50PihjYXJvdXNlbEVsZW1lbnQsICd0b3VjaGVuZCcpO1xuICAgICAgY29uc3QgdG91Y2hNb3ZlJCA9IGZyb21FdmVudDxUb3VjaEV2ZW50PihjYXJvdXNlbEVsZW1lbnQsICd0b3VjaG1vdmUnKTtcbiAgICAgIHRoaXMuc3dpcGVTdWJzY3JpcHRpb24gPSB0b3VjaFN0YXJ0JC5waXBlKFxuICAgICAgICB6aXBXaXRoKHRvdWNoRW5kJC5waXBlKHdpdGhMYXRlc3RGcm9tKHRvdWNoTW92ZSQpKSksXG4gICAgICAgIHRha2VVbnRpbERlc3Ryb3llZCh0aGlzLiNkZXN0cm95UmVmKVxuICAgICAgKVxuICAgICAgICAuc3Vic2NyaWJlKChbdG91Y2hzdGFydCwgW3RvdWNoZW5kLCB0b3VjaG1vdmVdXSkgPT4ge1xuICAgICAgICAgIHRvdWNoc3RhcnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgdG91Y2htb3ZlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGNvbnN0IGRpc3RhbmNlWCA9IHRvdWNoc3RhcnQudG91Y2hlc1swXS5jbGllbnRYIC0gdG91Y2htb3ZlLnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoZGlzdGFuY2VYKSA+IDAuMyAqIGNhcm91c2VsRWxlbWVudC5jbGllbnRXaWR0aCAmJiB0b3VjaHN0YXJ0LnRpbWVTdGFtcCA8PSB0b3VjaG1vdmUudGltZVN0YW1wKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSB0aGlzLmNhcm91c2VsU3RhdGUuZGlyZWN0aW9uKGRpc3RhbmNlWCA+IDAgPyAnbmV4dCcgOiAncHJldicpO1xuICAgICAgICAgICAgdGhpcy5jYXJvdXNlbFN0YXRlLnN0YXRlID0geyBhY3RpdmVJdGVtSW5kZXg6IG5leHRJbmRleCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3dpcGVTdWJzY3JpcHRpb24/LnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG59XG4iXX0=